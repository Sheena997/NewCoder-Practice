/*
面试题 17.09. 第 k 个数
有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。

示例 1:

输入: k = 5

输出: 9

来源：LeetCode
链接：https://leetcode-cn.com/problems/get-kth-magic-number-lcci/
*/
/*
三指针法：因为丑数只是因数只有2,3,5的数;

所以先设置一个dp数组表示当前已经找出并排列好的丑数数组；

再3个指针：i,j,k 表示 将当前已经排好的数组元素 *2，*3，*5 所得的数组（实际上，因为所得的数字最终会加入唯一的排序数组，所以并不用真正将3个数组建立起来），

因为排序后数组*2，*3，*5得到的也是已经排序数组，接下来的目的就是从这3个虚拟数组中的头元素中取得最小那个值；（实际上并不会出现3个数组）

所以关键就是如何用这3个指针进行选择，

实际上排序并不是在加入排序数组后才整理排序，而是每次用老元素*2，*3，*5生成新元素的时候，选择最小的加入达到排序目的，这个时候指针移动就起到作用了，如下过程所示：

-----------------------------------------------------

已经排好的数组，先放进第一个丑数1:[1]

排好数组*2 ：[1]*2=2

排好数组*3 ：[1]*3=3

排好数组*5 ：[1]*5=5

选结果中最小的数加入数组，此时明显是2，新的排序数组为[1,2]；

-----------------------------------------------------

已经排好的数组:[1，2]------此时上次结果中，2，3，5只用到了2；但3明显是这次需要加入的数；既然2已经加入，再去对比2没意义了，那么就将 （*2的指针） [1]转向下一位[2]，对比 （下一个元素*2 和3，5）的大小，取最小的加入；

排好数组*2 ：[2]*2=4

排好数组*3 ：[1]*3=3

排好数组*5 ：[1]*5=5

选结果中最小的数加入数组，此时明显是2，新的排序数组为[1,2,3]；

-----------------------------------------------------

已经排好的数组:[1，2，3]------3已经加入，移动它的指针到排序数组下一位；

排好数组*2 ：[2]*2=4

排好数组*3 ：[2]*3=6

排好数组*5 ：[1]*5=5

选结果中最小的数加入数组，此时明显是4，新的排序数组为[1,2,3,4]；

依次类推；可以看到，实际上，只需将指针进行分别移动就可以了；所以要做出3个指针；

-----------------------------------------------------

维护3个值val2,val3,val5，表示将当前排列好数组 分别*2，*3，*5所得的结果数；

因为可能3组数出现重复现象，所以要判断是否重复后再加入
*/
class Solution {
public:
    int getKthMagicNumber(int k) {
        vector<int> dp(k);
        int f3 = 0, f5 = 0, f7 = 0;
        dp[0] = 1;
        
        for(int i = 1; i < k; ++i)
        {
            dp[i] = min(min(3 * dp[f3], 5 * dp[f5]), 7 * dp[f7]);
            
            if(dp[i] == 3 * dp[f3])
                ++f3;
            if(dp[i] == 5 * dp[f5])
                ++f5;
            if(dp[i] == 7 * dp[f7])
                ++f7;
        }
        
        return dp[k - 1];
    }
};